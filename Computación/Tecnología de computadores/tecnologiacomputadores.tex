\documentclass[a4paper, 11pt, titlepage]{article}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{imakeidx}
\usepackage{makeidx}
\usepackage{mathtools}
\usepackage[spanish]{babel}
\usepackage{eurosym}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{mathtools}
\usepackage{blkarray, bigstrut}
\usepackage{stackrel} 

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

\title{{\scshape\Huge Teoría de la Tecnología y Estructura de computadores \par}}
\author{Francisco Javier Balón Aguilar}

\begin{document}

\maketitle
\renewcommand{\contentsname}{Índice}
\tableofcontents
\newpage
%Lista de figuras 
\listoffigures
\newpage

\section{Álgebra de Boole y puertas lógicas}

    El matemático y filósofo George Boole enunció una teoría matemática que permitía, de forma algebráica, representar y operar con lógica preposicional. Una de sus características más importantes es que las variables sólo podían tener dos valores: verdadero y falso. A esta teoría se le conoce como Álgebra de Boole.

    Posteriormente, Claude E. Shannon, ingeniero electrónico, llega a la conclusión de que es posible aplicar el Álgebra de Boole para el diseño, estudio y simplificación de circuitos digitales. Uno de los factores que lo permiten son la simplificación a dos los valores de las variables.

    El Álgebra de Boole queda definida, pues, por las siguientes reglas:

    \begin{itemize}
        \item Las variables sólo tienen dos posibles valores: 0 ó 1, es decir, utilizamos el sistema de numeración binario.
        \item Operación de complementación o función NOT.
        \item Operación de suma lógica o función OR.
        \item Operación de producto lógico o función AND.
        \item Por convenio, el producto lógico es precedente a la suma lógica.
    \end{itemize}

    Estas operaciones algebráicas se implementan en los circuitos digitales mediante \textbf{puertas lógicas}. Cada operación tiene asignada una puerta lógica.

    % TODO: poner gráfica con la representación de las puertas lógicas.

    Para representar los posibles resultados de la función lógica en función de las entradas se utilizan las \textbf{tablas de verdad}. Ésta consta de una serie de columnas que representan las variables de entrada y de salida, representando todas las combinaciones posibles de entradas.

    \begin{figure}[htp]
      \centering
      \includegraphics[width=1\textwidth]{resources/boole-or.png}
      \caption{Representación gráfica y tabla de verdad de la puerta lógica OR}
      \label{boole-or}
    \end{figure}

    \begin{figure}[htp]
      \centering
      \includegraphics[width=1\textwidth]{resources/boole-and.png}
      \caption{Representación gráfica y tabla de verdad de la puerta lógica AND}
      \label{boole-and}
    \end{figure}

    \begin{figure}[htp]
      \centering
      \includegraphics[width=1\textwidth]{resources/boole-not.png}
      \caption{Representación gráfica y tabla de verdad de la puerta lógica NOT}
      \label{boole-not}
    \end{figure}

    Las puertas lógicas OR, AND y NOT son conocidas como funciones básicas (véanse figuras \ref{boole-or}, \ref{boole-and} y \ref{boole-not}), cuyas operaciones cumplen las siguientes propiedades:

    \begin{itemize}
      \item Conmutativa: $x+y=y+x$; $x\cdot y=y\cdot x$
      \item Elemento identidad: $x+0=x$; $x\cdot1=x$
      \item Propiedad distributiva: 
        \[x\cdot(y+x)=x\cdot y + x\cdot z\]
        \[x+(y\cdot z)=(x+y)\cdot(x+z)\]
      \item Elemento complementario: $x+\overline{x}=1$; $x\cdot\overline{x}=0$
      \item Propiedad de idempotencia: $x+x=x$; $x\cdot x=x$
      \item Elemento nulo: $x+1=1$; $x\cdot 0=0$
      \item Ley de convolución: $ \stackbin{=}{x}=x$
      \item Ley de absorción: $x+x\cdot y=x$; $x\cdot(x+y)=x$
      \item Propiedad asociativa: $x+(y+z)=(x+y)+z$; $x\cdot(y\cdot z)=(x\cdot y)\cdot z$
      \item Teorema del consenso:
        \[xy+\overline{x}z=xy+\overline{x}z+yz\]
        \[(x+y)(\overline{x}+z)=(x+y)(\overline{x}+z)(y+z)\] 
      \item Teorema de Morgan:
        \[\overline{x+y}=\overline{x}\cdot\overline{y}\]
        \[\overline{x\cdot y}=\overline{x}+\overline{y}\]
        \[x+\overline{x}y=x+y\]
        \[x\cdot(\overline{x}+y)=xy\]
    \end{itemize}

    Hay otras funciones que pueden realizarse como combinación de las funciones básicas, siendo muy útiles en el diseño de circuitos digitales. Estas funciones son denominadas \textbf{funciones no básicas} (véanse figuras \ref{boole-nor}, \ref{boole-nand} y \ref{boole-xor}).

    \begin{figure}[htp]
      \centering
      \includegraphics[width=1\textwidth]{resources/boole-nor.png}
      \caption{Representación gráfica y tabla de verdad de la puerta lógica NOR}
      \label{boole-nor}
    \end{figure}

    \begin{figure}[htp]
      \centering
      \includegraphics[width=1\textwidth]{resources/boole-nand.png}
      \caption{Representación gráfica y tabla de verdad de la puerta lógica NAND}
      \label{boole-nand}
    \end{figure}

    \begin{figure}[htp]
      \centering
      \includegraphics[width=1\textwidth]{resources/boole-xor.png}
      \caption{Representación gráfica y tabla de verdad de la puerta lógica XOR}
      \label{boole-xor}
    \end{figure}

	\subsection{Forma canónica de las funciones lógicas}

		A partir de una función lógica podemos, mediante operaciones algebráicas, obtener otras funciones lógicas equivalentes. O lo que es lo mismo, una función lógica puede expresarse algebráicamente de muchas formas, siendo una de ellas la forma canónica.

		\subsubsection{Suma de minterms}

			La forma canónica de una función lógica expresada como suma de minterms\footnote{
				Un \textit{minterm} es un producto de todas las variables (negadas o sin negar) de una función lógica.

				Para saber si un \textit{minterm} va negado o no debemos observar si la entrada es 0 ó 1; si es 0 la variable estará negado mientras que si es 1 la variable no estará negada.
			} contiene la suma de todas las combinaciones de las entradas de tal forma que la salida sea igual a 1.

		\subsubsection{Producto de maxterms}

			La forma canónica de una función lógica expresada como un producto de maxterms\footnote{
				Un \textit{maxterm} es una suma de todas las variables (negadas o sin negar) de una función lógica.
			} contiene el producto de todas las combinaciones de las entradas que van a hacer que la salida sea 0.

	\subsection{Simplificación de funciones lógicas}

		La simplificación consiste en la búsqueda de la función lógica que minimice el uso de puertas lógicas. Una de las posibilidades consiste en utilizar los teoremas anteriormente vistos.

		Ejemplo:
		\begin{gather*} 
			D = \overline{B}C + \overline{A}BC + ABC + \overline{A}B\overline{C} \\ 
			D = \overline{B}C + \overline{A}B\overline{C} + BC(\overline{A} + A) \\
			D = \overline{B}C + \overline{A}B\overline{C} + BC \\
			D = \overline{A}B\overline{C} + C(\overline{B} + B) \\
			D = \overline{A}B\overline{C} + C \\
			D = \overline{A}B+ C
		\end{gather*}

		\subsubsection{Homogeneización de puertas}

			Es posible implemnentar cualquier función lógica utilizando únicamente las puertas NAND y NOR.
    
		\subsubsection{Mapas de Karnaugh}

			Los mapas de Karnaugh permiten simplificar funciones lógicas de una forma gráfica, sencilla y sistemática, representando en una tabla (mapa) con características de la tabla de verdad de una función. Debe tener las siguientes características:

			\begin{enumerate}
				\item Las posibles combinaciones de variables de entrada se colocan en filas y columnas. Entre las combinaciones de entradas de dos filas o dos columnas consecutivas no debe variar más de un bit.
				\item En cada celda de la tabla resultante debemos colocar el valor de la función lógica para la combinación de entradas correspondientes. 
			\end{enumerate}

\section{Circuitos combinaciones}

	\subsection{Diseño de circuitos combinacionales}

		Los circuitos combinacionales son aquellos en los que las salidas sólo dependen de las entradas del mismo instante. El proceso de diseñó consta de las siguientes etapas:

		\begin{enumerate}
			\item Construcción de la tabla de verdad para la función lógica que se pretende implementar.
			\item Simplificación de tabla previamente construida.
			\item Implementación de la función.
		\end{enumerate}

		Una línea de control permite que, en función del valor de las entradas el circuito se comportará de una forma u otra. En función del nivel de la señal que se escoja para establecer la activación o no de un determinado comportamiento, existen dos tipos de líneas de control:

		\begin{itemize}
			\item Activas a bajo nivel (cero lógico). El valor de la línea es 0.
			\item Activas a alto nivel (uno lógico). Es valor de la línea es 1.
		\end{itemize}

	\subsection{Circuitos airitméticos}

		Las operaciones aritméticas son fundamentales en cualquier computador, siendo parte importante del procesamiento de la información. Los circuitos que realizan operaciones de este tipo son conocidos como circuitos aritméticos y son parte fundamental de las unidades aritmético-lógicas, que forman a su vez parte de las CPUs. Estas operaciones se realizan en binario.

		\subsubsection{Sumadores}

			La suma es la operación más importante de la aritmética binaria, basándose el resto de operaciones en ella.

			\[0 + 0 = 0\]
			\[0 + 1 = 1\]
			\[1 + 0 = 1\]
			\[1 + 1 = 10\]

			En ésta última el resultado es 0 y se produce un acarreo, que posteriormente se procesará, almacenará o desechará.

			\paragraph{Semisumador binario} La función del semisumador es sumar dos bits de entrada ($A$ y $B$), generar una suma ($S$) y un acarreo de salida ($C_{out}$).

			\paragraph{Sumador completo} Un sumador completo tiene tres entradas, siendo la tercera la posibilidad de sumar una erntrada de acarreo $C_{in}$. Esta entrada adicional permite encadenar varios sumadores, de tal forma que se implementan sumadores de más de un bit; el acarreo vendría a sumar el bit anterior.

			\paragraph{Sumador de más de un bit} Para implementar la suma de números binarios se requieren tantos sumadores completos como bits tengan los números que se quieren sumar, ya sea mediante acarreo serie\footnote{
				El acarreo resultante de la suma de un bit se utiliza como entrada para el sumador del bit de orden superior. De tal forma que para calcular la suma del bit de orden $n$ sea necesario completar la suma de los $n-1$ anteriores bits. 

				Por eso, estos sumadores son poco escalables, ya que cuantos más bits tengamos, más lento será el sumador.
			} o acarreo anticipado.

		\subsubsection{Restadores}

			Para restar en binario debemos considerar las combinaciones posibles:

			\[0 - 0 = 0\]
			\[0 - 1 = 1\]
			\[1 - 0 = 1\]
			\[1 - 1 = 0\]

			En el caso de $0 - 1$ obtendremos un acarreo.

		\subsubsection{Multiplicaciones y divisiones}

			Antiguamente, la multiplicación y división se obtenía en descomposición del problema en sumas y restas, con el consiguiente aumento de tiempo de cálculo. Actualmente se incluyen circuitos específicos que realizan estas operaciones aritméticas. 
			
			Estos circuitos pueden ser combinacionaleso secuenciales.

	\subsection{Comparadores}

		La comparación de magnitudes se realiza mediante un circuito lógico denominado comparador.

		Un número en formato binario se introduce en la entrada $A$ y otro en la entrada $B$. Las salidas $E$, $G$ y $L$ indican la relación entre los dos números, produciendo un nivel alto en la línea de salida correspondiente; $E = 1$ si $A = B$, $G = 1$ si $A > B$ y $L = 1$ si $A < B$. 

	\subsection{Unidades aritmético-lógicas}

		La unidad aritmético-lógica (ALU) es un circuito combinacional capaz de realizar una amplia serie de operaciones aritméticas y lógicas entre dos palabras de $n$ bits. El tipo de operaciones a realizar entre ambas palabras es elegido mediante unas entradas de control de la ALU.

		\begin{figure}[htp]
			\centering
			\includegraphics[width=0.7\textwidth]{resources/alu2bits.png}
			\caption{Unidad aritmético-lógica de dos bits}
			\label{alu2bits}
		\end{figure}

		La figura \ref{alu2bits} representa una ALU de dos bits. Las entradas $A0$ y $B0$ se corresponden con el bit menos significativo de los números de entrada; a diferencia de las entradas $A1$ y $B1$, que corresponden con el bit más significativo.

		Las entradas $A$ y $B$ se dirigen hacia las cuatro puertas: XOR, AND, OR y XOR. Por último se realiza una multiplexación para seleccionar la salida de qué operación se quiere dar como salida de la ALU. La entrada $OP0-2$ determina cuál de las funciones se van a realizar:

		\begin{itemize}
			\item $OP = 000 \Rightarrow XOR$
			\item $OP = 001 \Rightarrow AND$
			\item $OP = 010 \Rightarrow OR$
			\item $OP = 011 \Rightarrow $ Suma
		\end{itemize}
  
		Estas entradas son las líneas de control de la ALU y sirven para seleccionar qué operación queremos que realice.

	\subsection{Generadores y comprobadores de paridad}

		La paridad es un método de validación de la información codificada en binario. Consiste en añadir un bit que hace que el número de 1s que aparece en la información sea par (paridad par) o impar (paridad impar). Por ejemplo, en caso de utilizar paridad par:

		\[00110100 \rightarrow 001101001\]
		\[10011100 \rightarrow 100111000\]

		Y en el caso de utilizar paridad impar:

		\[00110100 \rightarrow 001101000\]
		\[10011100 \rightarrow 100111001\]

		De esta forma podemos detectar un error en la información, si este error se produce en un único bit y sólo permite detectar errores, no corregirlos.

		Este tipo de comprobación suele usarse en transmisiones de información seguras; o de almacenamiento de información (en memoria principal, por ejemplo) al que quiere dotársele de una seguridad muy alta:

		\[00110100 \xrightarrow[]{\text{paridad par}} 001101001 \xrightarrow[]{\text{transmisión}} 00110001 \rightarrow err\] 

		Sin embargo, hay que tener en cuenta que si hay un error en más de un bit puede no haber detección:
		
		\[00110100 \xrightarrow[]{\text{paridad par}} 001101001 \xrightarrow[]{\text{transmisión}} 001100101 \rightarrow ok\] 

	\subsection{Multiplexores}

		Un multiplexor es un circuito que transmite los datos digitales procedentes de una de sus líneas de entrada a una única línea de salida, según se especifique en sus líneas de control.

		Funcionalmente se pueden representar mediante una operación de conmutación electrónica, que secuencialmente conecta cada una de las líneas de entrada a la línea de salida; es un distribuidor de las entradas hacia una única salida (encaminador).

		Para un multiplexor de $n$ líneas de control el número de entradas será $2^n$.

		\begin{figure}[htp]
			\centering
			\includegraphics[width=0.7\textwidth]{resources/multiplexor.png}
			\caption{Representación de un multiplexor de dos entradas}
			\label{multiplexor}
		\end{figure}

		La figura \ref{multiplexor} es la representación de un multiplexor de dos entradas, que posee una entrada habilitadora que, cuando está activa, permite al multiplexor funcionar correctamente; en caso contrario el valor de salida es 0.

	\subsection{Demultiplexores}

		Un demultiplexor realiza la función inversa de un multiplexor; transmitiendo los datos digitales de una línea de entrada a una de varias líneas de salida, según la selección realizada.

		\begin{figure}[htp]
			\centering
			\includegraphics[width=0.7\textwidth]{resources/demultiplexor.png}
			\caption{Representación de un demultiplexor de dos entradas}
			\label{demultiplexor}
		\end{figure}

		Un demultiplexor de $n$ salidas tiene una entrada de datos y $c$ entradas de control, donde $n=2^c$.

	\subsection{Codificadores}

		Un código es un conjunto de bits ordenados de acuerdo a un modelo, empleado para representar información.Un convertidor de código cambia el formato de una información codificada a otro formato de código, implementándose mediante un circuito denominado codificador.

		Estos circuitos disponen de $2n$ entradas y $n$ salidas, tal y como vemos en la figura \ref{codificador}.

		\begin{figure}[htp]
			\centering
			\includegraphics[width=0.7\textwidth]{resources/codificador.jpg}
			\caption{Representación de un codificador binario}
			\label{codificador}
		\end{figure}

		\subsubsection{Codificador binario}

			Muestra en la salida el valor binario del número de la entrada seleccionada.

		\subsubsection{Codificador decimal-BCD con prioridad}

			Realiza la misma función y además puede emplearse para detectar prioridad\footnote{
				La función de prioridad significa que cuando hay varias entradas decimales activas, el codificador producirá la salida BCD correspondiente al dígito decimal de entrada de más alto orden que se encuentre activo, e ignorará cualquier otra entrada activa.

				Por ejemplo: para las entradas activas $6$ y $3$, la salida BCD será $0110$ ($6$ en binario).
			}.
	\subsection{Decodificadores}

		Un decodificador es un circuito combinacional que convierte la información codificada en otra información no codificada. Uno de sus usos más habituales es el direccionamiento de la memoria del computador. 

		Un decodificador de $n$ entradas es capaz de direccionar $2^n$ direcciones.

		\subsubsection{Decodificador binario/decimal}

			Genera una salida para cada combinación de entrdas, siendo ésta la entrada pero decodificada. Para poder decodificar todas las posibles combinaciones de las entradas son necesarias $2^n$ salidas, siendo $n$ el número de entradas.

		\subsubsection{Decodificador BCD/decimal}

			Convierte código BCD en uno de los diez posibles dígitos decimales. Frecuentemente se le denomina decodificador de 4 líneas a 10 líneas.

		\subsubsection{Decodificador BCD/7 segmentos}

			Acepta código BCD en sus entradas y proporciona salidas capaces de excitar un display de 7 segmentos para mostrar un dígito decimal, donde cada segmento puede encenderse o apagarse de forma individual, denominados cada uno con una letra.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.4\textwidth]{resources/7segmentos.jpg}
				\caption{Display de 7 segmentos}
				\label{7segmentos}
			\end{figure}

			Para representar un número es necesario encender los segmentos adecuados (véase figura \ref{7segmentos}), por ejemplo, para representar el número 2 es necesario encender los segmentos $a$, $b$, $g$, $e$ y $d$.

		\subsubsection{Conexión en cascada}

			Es posible conectar varios decodificadores en cascada para aumentar el número de entradas y salidas.
	
\section{Circuitos secuenciales}

	Como hemos estudiado, en la lógica combinacional las salidas están determinadas sólo por el valor de las entradas, y las salidas no sólo están condicionadas por las entradas sino también por la secuencia de entradas precedentes\footnote{La secuencia de entradas anteriores define un estado de circuito}. Y para poder almacenar el estado en el que se encuentra el circuito es necesario que este disponga de memoria.

	Por lo tanto, la salida de un sistema secuencial está determinada por las entradas presentes y por la información almacenada en los elementos de memoria.

	\begin{figure}[htp]
		\centering
		\includegraphics[width=0.7\textwidth]{resources/circuitosecuencial.jpg}
		\caption{Estructura general de un sistema secuencial}
		\label{circuitosecuencial}
	\end{figure}

	Como vemos en la figura \ref{circuitosecuencial}, el circuito se compone de dos partes fundamentales:

	\begin{itemize}
		\item Lógica combinacional que convierte las entradas y el estado actual del circuito en la salida y el estado siguiente (estado en el que se queda el circuito).
		\item Memoria\footnote{
			La mayoría de los sistemas digitales necesitan almacenar información, de hecho suele ser la razón de ser del circuito. Algunos tipos de dispositivos de almacenamiento son: biestables, registros, memorias semiconductoras, discos magnéticos, cintas magnéticas y discos ópticos.
		} que almacena el estado en el que se encuentra el circuito.
	\end{itemize}

	En lógica secuencial es importante el parámetro temporal, pudiendo ser:

	\begin{itemize}
		\item \textbf{Circuitos síncronos}. El estado y la salida cambian cuando se produce un evento de reloj y en las entradas existen valores adecuados. Por lo tanto, existe una señal (en este caso un reloj que genera una señal cuadrada de periodo fijo) que controla la actividad del circuito.

		Los eventos de reloj posibles son:

		\begin{itemize}
			\item Nivel alto de reloj (uno lógico).
			\item Nivel bajo de reloj (cero lógico).
			\item Flanco de subida (el valor de la señal pasa de cero lógico a uno lógico).
			\item Flanco de bajada (el valor de la señal pasa de uno lógico a cero lógico).
		\end{itemize}

		Aunque la señal de reloj de forma ideal es cuadrada, realmente tiene la forma que podemos observar en la figura \ref{clocksignal}. Como observamos, los niveles lógicos son realmente intervalos de voltaje que hacen que se activen los elementos adecuados del circuito secuencial para que se genere la salida y el estado siguiente.

		\begin{figure}[htp]
			\centering
			\includegraphics[width=0.8\textwidth]{resources/clocksignal.png}
			\caption{Señal de reloj}
			\label{clocksignal}
		\end{figure}
	
		\item \textbf{Circuitos asíncronos}. El estado y la salida cambian cuando hay un cambio en las entradas.
	\end{itemize}

	\subsection{Biestables}

		Un biestable es un circuito lógico que posee dos estados estables, denominados SET (1) y RESET (0), en los cuales se puede mantener indefinidamente, permitiendo el almacenamiento de un bit. Son implementados mediante puertas lógicas y son bloques básicos de construcción de contadores, registros... También son empleados en ciertos tipos de memorias.

		\subsubsection{Biestable RS}\label{biestablers}

			Siendo RS = RESET-SET con entrada activa a nivel alto, es un tipo de dispositivo lógico con dos salidas $Q$ y $\overline{Q}$, siendo una complementaria de la otra. El funcionamiento es el siguiente:

			\begin{enumerate}
				\item Si dos entradas están a 0 la salida permanece igual.
				\item Si la entrada $S$ está a 1 y la entrada $R$ a 0 (SET) la entrada $Q$ estará a 1 y la complementaria a 0.
				\item Si la entrada $S$ está a 0 y la entrada $R$ está a 1 (RESET) la entrada $Q$ estará a 0 y la complementaria a 1.
				\item Si ambas entradas están a 1 ambas salidas estarán a 0\footnote{
					Esto no concuerda con las deficiniones dadas para las salidas, siendo que una es complementaria a la otra, por lo que se dice que es un estado erróneo.
				}.
			\end{enumerate}

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.8\textwidth]{resources/biestablesrsnor.jpg}
				\caption{Biestable RS-NOR. Implementación posible usando puertas NOR}
				\label{biestablesrsnor}
			\end{figure}
	
		\subsubsection{Biestable D}

			Dispone únicamente de una entrada para realizar operaciones de SET y RESET, disponiendo también de entrada de habilitación (véase figura \ref{biestabled}).

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.3\textwidth]{resources/biestabled.jpg}
				\caption{Representación simbólica del biestable D}
				\label{biestabled}
			\end{figure}

			Una posible implementación utilizando puertas NAND sería la observada en la figura \ref{biestabled2}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.7\textwidth]{resources/biestabled2.png}
				\caption{Diagrama de un biestable D}
				\label{biestabled2}
			\end{figure}

		\subsubsection{Biestable JK}

			Con un funcionamiento similar al biestable RS (véase sección \ref{biestablers}), salvo que soluciona el problema de tener una salida errónea cuando las entradas se encuentran activas a la vez si es activo por flanco. La entrada $J$ es la equivalente a la entrada $S$. y la entrada $K$ a la $R$ (véase figura \ref{biestablejk}).

			Este biestable hace que la salida cambie al valor contrario cuando las dos entradas se colocan a nivel alto, denominándose \textbf{basculación}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.3\textwidth]{resources/biestablejk.jpg}
				\caption{Representación simbólica del biestable JK}
				\label{biestablejk}
			\end{figure}

		\subsubsection{Entradas asíncronas en los biestables}

			En muchas salidas resulta útil poder poner la salida de un biestable a un determinado valor independientemente del reloj y de las entradas. Es por esto que muchos dispositivos tienen entradas adicionales para ello. Estas entradas reciben el nombre de entradas asíncronas ya que no dependen del reloj. Las dos más típicas son:

			\begin{itemize}
				\item PRESET (PRE). Coloca la salida a nivel alto.
				\item CLEAR (CLR). Coloca la salida a bajo nivel.
			\end{itemize}

			En la figura \ref{entradasasincronas} se observa un biestable JK con entradas asíncronas.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.2\textwidth]{resources/entradasasincronas.png}
				\caption{Biestable JK con entradas asíncronas}
				\label{entradasasincronas}
			\end{figure}

		\subsubsection{Parámetros temporales}

			Existen una serie de parámetros temporales a tener en cuenta a la hora de diseñar circuitos secuenciales:

			\begin{itemize}
				\item \textbf{Tiempo de propagación ($t_{co}$)}. Es el tiempo que transcurre desde que llega un pulso de reloj o se activa una entrada asíncrona hasta que la salida toma el valor correspondiente.
				\item \textbf{Tiempo de setup ($t_{su}$)}. Es el tiempo que transcurre desde que se activa una entrada hasta que llega la señal de reloj que habilita el circuito.
				\item \textbf{Tiempo de hold ($t_{t_h}$)}. Es el tiempo que transcurre desde que llega la señal de reloj que habilita el circuito hasta que se desactiva una entrada.
			\end{itemize}

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.2\textwidth]{resources/partemp.png}
				\caption{Parámetros temporales}
				\label{partemp}
			\end{figure}

	\subsection{Registros}

		Uno de los elementos de memoria básico en todos los computadores es el registro, que está formado por un conjunto de biestables interconectados entre ellos de forma que almacenen y desplacen la información. Es un circuito digital que con dos funciones: almacenamiento y movimiento de datos.

		Un registro de desplazamiento que permite almacenar $n$ bits estará formado por $n$ biestables, uno por bit que se desea almacenar.

		Existen dos tipos básicos de tratamiento de la información por parte de los registros, serie y paralelo; que pueden combinarse tal que:

		\subsubsection{Registro de entrada serie, salida serie}

			La salida de un biestable tipo D se conecta a la entrada del siguiente, de tal forma que en cada pulso de reloj los bits van pasando de uno en uno en cada biestable. Véase figura \ref{serie_serie}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.8\textwidth]{resources/serie_serie.png}
				\caption{Registro de entrada serie, salida serie}
				\label{serie_serie}
			\end{figure}

			Otra posible implementación, para 5bits en este caso y utilizando biestables RS puede ser la expuesta en la figura \ref{serie_serie2}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.8\textwidth]{resources/serie_serie2.png}
				\caption{Registro de entrada serie, salida serie con biestables RS}
				\label{serie_serie2}
			\end{figure}

		\subsubsection{Registro de entrada serie, salida paralelo}

			Se toman las salidas de cada biestable para construir la salida en paralelo, como la carga o almacenamiento de los datos se realiza en serie, cuando se ha cargado el último biestable podemos tomar una lectura de todos ellos a la vez. Véase figura \ref{serie_paralelo}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.8\textwidth]{resources/serie_paralelo.png}
				\caption{Registro de entrada serie, salida paralelo}
				\label{serie_paralelo}
			\end{figure}

		\subsubsection{Registro de entrada paralelo, salida serie}

			La entrada de datos se realiza en paralelo, añadiendo lógica adicional y una entrada que indica al circuito si tiene que cargar el registro o desplazar la información hacia la salida. Véase figura \ref{paralelo_serie}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.8\textwidth]{resources/paralelo_serie.png}
				\caption{Registro de entrada paralelo, salida serie}
				\label{paralelo_serie}
			\end{figure}

			Otra posible implementación utiliza biestables de tipo RS y multiplexores de dos entradas y una salida para construir un registro de 3 bits. Véase figura \ref{paralelo_serie2}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.8\textwidth]{resources/paralelo_serie2.png}
				\caption{Registro de entrada paralelo, salida serie con biestables RS y multiplexores}
				\label{paralelo_serie2}
			\end{figure}

		\subsubsection{Registro de entrada paralelo, salida paralelo}

			Los biestables sólo comparten la entrada de reloj. Las entradas entran directamente a la entrada de cada biestable y para la salida se toma la salida de cada biestable. Véase figura \ref{paralelo_paralelo}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.8\textwidth]{resources/paralelo_paralelo.png}
				\caption{Registro de entrada paralelo, salida paralelo}
				\label{paralelo_paralelo}
			\end{figure}

		\subsubsection{Registro universal}

			Mediante dos entradas de control realiza las funciones de almacenamiento y desplazamiento de bits de todos los registros vistos anteriormente. Puede hacer los desplazamientos en ambas direcciones. Véase figura \ref{registrouniversal}.
				
			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.8\textwidth]{resources/registrouniversal.png}
				\caption{Registro universal}
				\label{registrouniversal}
			\end{figure}

			\paragraph{Registro universal: 74LS194}

				Este integrado implementa un registro universal de 4 bits utilizando biestables de tipo RS. Dispone de cuatro entradas en paralelo ($P0-P3$) y dos en serie ($D_{SR}$ y $D_{SL}$). También dispone de cuatro salidas en paralelo ($Q0-Q3$) y dos entradas de control ($S0$ y $S1$). Cuenta con una entrada reset ($MR$) y una entrada de reloj. Véase figura \ref{registrouniversal2}.

				\begin{figure}[htp]
					\centering
					\includegraphics[width=0.4\textwidth]{resources/registrouniversal2.png}
					\caption{Registro universal 74LS194}
					\label{registrouniversal2}
				\end{figure}
	
				Su implementación interna es la expuesta en la figura \ref{registrouniversal3}.

				\begin{figure}[htp]
					\centering
					\includegraphics[width=1\textwidth]{resources/registrouniversal3.png}
					\caption{Diseño del registro universal 74LS194}
					\label{registrouniversal3}
				\end{figure}

	\subsection{Contadores}

		El objetivo es el de contar sucesos, normalmente flancos de subida o bajada en un reloj. 
		
		\subsubsection{Contadores síncronos}

			Todos los biestables del contador reciben en el mismo instante la señal de reloj.

			Su posible implementación de un contador síncrono utilizando biestables de tipo T se puede ver en la figura \ref{contador_sincrono}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.6\textwidth]{resources/contador_sincrono.png}
				\caption{Contador binario de 4 bits usando biestables T}
				\label{contador_sincrono}
			\end{figure}

			También es posible utilizar biestables D en la implementación. Véase figura \ref{contador_sincrono2}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.6\textwidth]{resources/contador_sincrono2.png}
				\caption{Contador binario de 4 bits usando biestables D}
				\label{contador_sincrono2}
			\end{figure}

			\paragraph{Contador Johnson}

				Se basa en un registro de desplazamiento. Es una cadena de biestables, cada uno de ellos conectado directamente al anterior. La salida del último biestable cierra la cadena al estar conectada a la entrada del primer biestable. Véase figura \ref{contador_johnson}.

				\begin{figure}[htp]
					\centering
					\includegraphics[width=0.5\textwidth]{resources/contador_johnson.png}
					\caption{Contador Johnson}
					\label{contador_johnson}
				\end{figure}

		\subsubsection{Contadores asíncronos}

			Los biestables no reciben en el mismo instante la señal de reloj. Véase figura \ref{contador_asincrono}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.6\textwidth]{resources/contador_asincrono.png}
				\caption{Contador asíncrono de 3 bits}
				\label{contador_asincrono}
			\end{figure}

			No todos los biestables actúan al mismo tiempo por culpa de los retardos, algo que además se hace más notorio a medida que crece el número de biestables. Esto hace que estos contadores sean más lentos.

	\subsection{Tipos de circuitos secuenciales}

		Teniendo en cuenta si los dispositivos de memoria están conectados al reloj del sistema directamente o no, podemos clasificar los sistemas secuenciales en:

		\subsubsection{Circuitos asíncronos}

			Las salidas, ante un cambio en sus entradas, alcanzan sus niveles definitivos transcurrido un tiempo en función de los tiempos de propagación del circuito combinacional y de los elementos de memoria. 
			
			Por lo tanto, durante un periodo de tiempo las salidas no serán definitivas y podrán oscilar si unas líneas de salida cambian antes que otras, por lo que para que la salida de un circuito secuencial asíncrono pueda servir como entrada a otro circuito hay que esperar un tiempo hasta que los valores de salida sean definitivos.

		\subsubsection{Circuitos síncronos}

			Eliminan el problema anterior utilizando una señal de sincronismo o señal de reloj. Los cambios en las entradas y en los estados internos sólo tienen efecto sobre el resto del sistema en instantes discretos de tiempo que coinciden con los flancos de subida o bajada de la señal de reloj.
			
			Los circuitos síncronos suelen ser más lentos que los asíncronos debido a la espera que debe producirse entre que las salidas alcanzan sus niveles definitivos y el flanco de subida o bajada que hará que puedan ser utilizadas como entradas para otros circuitos. Sin embargo, son más sencillos de implementar, por lo que suelen utilizarse en sistemas complejos como puede ser un computador.

		\subsubsection{Autómatas finitos}

			Se puede definir como autómata cualquier sistema que pueda transformar una serie de entradas en salidas, es decir, procesar información. Esto abarca desde autómatas sencillos (contadores digitales, sumadores, registros, unidades de control) hasta autómatas complejos (computador).
		
			El modelo matemático que describe un sistema secuencial síncrono es la máquina de estados finitos o autómata de estados finitos. El estado en el que se encuentre el autómata debe almacenarse en una memoria interna, y, para que puedan implementarse, esa memoria debe ser finita, por lo que también serán finitos los estados que podrá almacenar.

			Si a una máquina de estados finitos (MEF) se le introducen una serie de datos de entrada a lo largo del tiempo $x(t)$, la salida $z(t)$ de la MEF en un instante determinado será función de la entrada en ese instante y del estado en el que se encuentre el autómata en ese instante de tiempo $q(t)$.

			Si la memoria tiene $p$ elementos ($M_0.... M_{p-1}$), siendo p un número finito ya que el autómata debe ser finito, el número máximo de estados que se pueden almacenar será $2^p$. Uno de estos estados será el estado inicial del autómata desde el cual evolucionará en función de las entradas y los estados por los que pase. Véase figura \ref{sistema_secuencial_sincrono}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.6\textwidth]{resources/sistema_secuencial_sincrono.png}
				\caption{Estructura general de un sistema secuencial síncrono}
				\label{sistema_secuencial_sincrono}
			\end{figure}

			Las dos implementaciones básicas de los autómatas finitos son:

			\begin{itemize}
				\item \textit{Máquina de Mealy}. La salida $z(t)$ depende tanto del estado actual $q(t)$ como
				de las entradas actuales $x(t)$.
				\item \textit{Máquina de Moore}. La salida $z(t)$ es función únicamente del estado actual
				$q(t)$.
			\end{itemize}

	\subsection{Análisis y síntesis de circuitos secuenciales síncronos}

		El proceso de análisis se puede sistematizar en una serie de pasos, que se describen a continuación para el caso de un \textit{autómata de Mealy} y posteriormente para un \textit{autómata de Moore}.
		
		\subsubsection{Análisis y síntesis de un \textit{autómata de Mealy}}

			Es un sistema con una única entrada ($X$) y una única salida ($Z$), y dos biestables, uno tipo JK y otro tipo D que almacenarán los dos bits que representan el estado del circuito (hay cuatro posibles estados). El biestable JK almacenará el bit menos significativo ($Q_0$) y el biestable D el más significativo ($Q_1$). El circuito es un \textit{autómata de Mealy} ya que la salida depende de la entrada y del estado en el que se encuentre el circuito, ya que la puerta NOR que hay justo antes de la salida tiene como entradas la salida de uno de los biestables y la entrada ($X$). Véase figura \ref{automata_mealy}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.8\textwidth]{resources/automata_mealy.png}
				\caption{Circuito a analizar como \textit{autómata de Mealy}}
				\label{automata_mealy}
			\end{figure}

			Los pasos a seguir para el análisis son:

			\begin{enumerate}
				\item Obtención de las ecuaciones lógicas de las señales que se están aplicando a las entradas de los biestables (tablas de excitación de los biestables).
				\[J=X\]
				\[K=Q_0\overline{Q_1}\]
				\[D=\overline{Q_0}\]
				\item Obtención de las ecuaciones lógicas del próximo estado, es decir, las próximas salidas de los biestables [$Q(t+1)$ ó $\overline{Q(t+1)}$]. Para ello se sustituirán las expresiones lógicas de las entradas (obtenidas en el punto anterior) en las ecuaciones de la salida del tipo de biestable que se esté utilizando.
				\[\text{Biestables JK: } Q(t+1)=J(t)\overline{Q(t)}+\overline{K(t)}Q(t)\]
				\[\text{Biestables T: } Q(t+1)=T(t)+Q(t)\]
				\[\text{Biestables D: } Q(t+1)=D(t)\]
				Susituyendo:
				\[Q_0(t+1)=X\overline{Q_0(t)}+\overline{Q_0(t)\overline{Q_1(t)}}Q_0(t)\]
				\[Q_1(t+1)=\overline{Q_0(t)}\]
				\item Obtención de la función lógica de salida. Al ser un \textit{autómata de Mealy}, por lo que la salida es función de la entrada y el estado actual.
				\[Z(t)=XQ_1(t)\]
				\item Representación de la tabla de estados, que representa todas las combinaciones posibles, toda la información obtenida hasta ahora pero en forma de tabla. Véase figura \ref{automata_mealy01}.
				
				\begin{figure}[htp]
					\centering
					\includegraphics[width=0.4\textwidth]{resources/automata_mealy01.png}
					\caption{Tabla de estados de \textit{autómata de Mealy}}
					\label{automata_mealy01}
				\end{figure}
	
				\item Asignación de nombres ($q_0$, $q_1$, $q_2$...) a cada combinación binaria de las salidas de los biestables, a todos los estados posibles.
				\[q_0=00\]
				\[q_1=01\]
				\[q_2=10\]
				\[q_3=11\]
				Véase la tabla de estados actualizada con la asignación en figura \ref{automata_mealy02}. 

				\begin{figure}[htp]
					\centering
					\includegraphics[width=0.4\textwidth]{resources/automata_mealy02.png}
					\caption{Tabla de estados de \textit{autómata de Mealy} después de asignación de nombres}
					\label{automata_mealy02}
				\end{figure}

				\item Representación del diagrama de estados o grafo de comportamiento del sistema. Véase figura \ref{automata_mealy03}.
				
				\begin{figure}[htp]
					\centering
					\includegraphics[width=0.6\textwidth]{resources/automata_mealy03.png}
					\caption{Grafo \textit{autómata de Mealy}}
					\label{automata_mealy03}
				\end{figure}
			\end{enumerate}

		\subsubsection{Análisis de un \textit{autómata de Moore}}

			Eliminamos la relación existente entre la entrada y la salida, de forma que la salida ahora es únicamente función del estado en el que se encuentre el circuito, creando un \textit{autómata de Moore}. Véase figura \ref{automata_moore}.

			\begin{figure}[htp]
				\centering
				\includegraphics[width=0.8\textwidth]{resources/automata_moore.png}
				\caption{Circuito a analizar como \textit{autómata de Moore}}
				\label{automata_moore}
			\end{figure}

			Los pasos a seguir para el análisis son:

			\begin{enumerate}
				\item Obtención de ecuaciones lógicas de las señales que se están aplicando a las entradas de los biestables (tablas de excitación de los biestables).
				\[J=X\]
				\[K=Q_0\overline{Q_1}\]
				\[D=\overline{Q_0}\]
				\item Obtención de ecuaciones lógicas del próximo estado, es decir, las próximas salidas de los biestables $Q(t+1)$ ó $\overline{Q(t+1)}$; sustituyendo las expresiones lógicas de las entradas en las ecuaciones de la salida del tipo de biestable que se esté utilizando.
				\[Q_0(t+1)=X\overline{Q_0(t)}+\overline{Q_0(t)\overline{Q_1(t)}}Q_0(t)\]
				\[Q_1(t+1)=\overline{Q_0(t)}\]
				\item Obtención de función lógica de la salida.
				\[Z(t)=Q_1(t)\]
				\item Representación de la tabla de estados.
				
				\begin{figure}[htp]
					\centering
					\includegraphics[width=0.6\textwidth]{resources/automata_moore01.png}
					\caption{Tabla de estados de \textit{autómata de Moore}}
					\label{automata_moore01}
				\end{figure}

				\item Asignación de nombres ($q_0$, $q_1$, $q_2$...) a cada combinación binaria de las salidas de los biestables, a todos los estados posibles.
				\[q_0=00\]
				\[q_1=01\]
				\[q_2=10\]
				\[q_3=11\]
				Véase la tabla de estados actualizada con la asignación en figura \ref{automata_moore02}. 

				\begin{figure}[htp]
					\centering
					\includegraphics[width=0.6\textwidth]{resources/automata_moore02.png}
					\caption{Tabla de estados de \textit{autómata de Moore} después de asignación de nombres}
					\label{automata_moore02}
				\end{figure}

				\item Representación del diagrama de estados o grafo de comportamiento del sistema. Véase figura \ref{automata_moore03}.
				
				\begin{figure}[htp]
					\centering
					\includegraphics[width=0.6\textwidth]{resources/automata_moore03.png}
					\caption{Grafo \textit{autómata de Mealy}}
					\label{automata_moore03}
				\end{figure}
			\end{enumerate}

\section{Unidad Central de Proceso (CPU)}\label{cpu}

    \subsection{Máquina de Von Neumann}

        La máquina de Von Neumann (1945) es un modelo computacional teórico referencia para 
        el diseño de arquitecturas de ordenadores.

        El modelo propone una unidad central de proceso (véase sección \ref{cpu}), que controla y gobierna la lógica 
        de la máquina, una memoria (véase sección \ref{memoria}) que contendrá instrucciones y datos, una unidad de entrada
        y salida (véase sección \ref{entradasalida}) que gestionará las entradas y salida de resultados, y un conjunto de periféricos.

        \begin{figure}[htp]
            \centering
            \includegraphics[width=0.7\textwidth]{resources/vonneumann.png}
            \caption{Diagrama del modelo de arquitectura Von Neumann.}
            \label{vonneumann}
        \end{figure}

        El modelo presentado, se orienta al
        procesado de información, requiriendo dos elementos: los datos y la lógica a aplicar 
        con ellos.

        Como características generales de todas las máquinas basadas en el modelo de Von Neumann, 
        podríamos citar:

        \begin{itemize}
            \item Uso de componentes lógicos básicos, tal y como puertas lógicas, transistores... 
            \item Configuración de uso general de funciones lógico-aritméticas.
            \item Uso de memoria, tanto para el almacenamiento de datos como de instrucciones.
            \item Uso de circuito secuencial (unidad de control). Véase la sección \ref{unidadcontrol} 
            para mayor detalle.
            \item Provisión de instrucciones y datos.
        \end{itemize}

        Tal y como se observa en la figura \ref{vonneumann}, los elementos que lo componen son:

        \subsubsection{Memoria en la máquina de Von Neumann}

            La memoria está compuesta por un conjunto de celdas de la misma longitud (mismo número de
            bits), que almacenan tanto datos como instrucciones, siendo cada una de ellas identificada 
            una dirección unívoca (dirección de memoria). El sistema puede leer la información contenida 
            en ellas y escribir nuevos datos.

        \subsubsection{Unidad aritmético-lógica (ALU) en la máquina de Von Neumann}

            En esta unidad se realizan las operaciones básicas lógicas y de tipo aritmético, 
            tales como sumar, restar, AND, OR, XOR...

            Los datos se obtienen de la memoria principal y se escriben en la misma los resultados 
            finales. Los resultados intermedios se almacenan temporalmente en registros de la propia 
            ALU.

        \subsubsection{Unidad de Control (UC) en la máquina de Von Neumann}

            Es la encargada de ejecutar las instrucciones almacenadas en memoria, procediendo previamente 
            a su captura y decodificación para después interpretando el tipo de instrucción a ejecutar y 
            generando posteriormente las señales de control para su interpretación.
            
        \subsubsection{Unidad de Entrada y Salida en la máquina de Von Neumann}

            Se encarga de gestionarla transferencia de información entre los periféricos y la unidad 
            central de proceso.

        \subsubsection{Buses en la máquina de Von Neumann}

            Son los elementos que interconectan los componentes. Su objetivo es por tanto la transferencia 
            de información, bien sean datos o señales entre los diferentes dispositivos.

            Por lo general distinguimos tres tipos de buses:

            \begin{itemize}
                \item \textbf{Buses de datos}.
                \item \textbf{Buses de control}.
                \item \textbf{Buses de direcciones}.
            \end{itemize}

    \subsection{Ciclo Básico de Instrucciones}

        Como ya se ha visto, es la unidad de control la encargada de ejecutar las instrucciones que procedan 
        en cada momento, siguiendo una serie de pasos básicos (véase también la figura \ref{cicloinstruccion}):

        \begin{enumerate}
            \item Pasar una instrucción de memoria a la unidad de control.
            \item Interpretar (decodificar) la instrucción.
            \item Ejecutar la instrucción:
            \begin{enumerate}
                \item Pasando los datos necesarios, accediendo a memoria con esas direcciones de los datos 
                calculadas para llevar los datos a la ALU y proveer registros en la ALU para su almacenamiento.
                \item Generando señales de control para la ejecución de las operaciones.
                \item Generando el resultado, ya sea en la ALU (si hay datos) o en la unidad de control (si no 
                existen datos).
            \end{enumerate}
            \item Ejecutar --si existe-- la siguiente instrucción.
        \end{enumerate}

        \begin{figure}[htp]
            \centering
            \includegraphics[width=0.8\textwidth]{resources/cicloinstruccion.jpg}
            \caption{Esquema del ciclo de instrucción.}
            \label{cicloinstruccion}
        \end{figure}

        \subsubsection{Registros y operaciones básicas}

            Los registros son un conjunto de biestables (bits) que se utilizan como almacén y que realizan las
            siguientes operaciones comunes:

            \begin{itemize}
                \item \textbf{Lectura}.
                \item \textbf{Escritura}.
                \item \textbf{Transferencia}. $(RA)\rightarrow RB$
                \item \textbf{Incremento} (INC). $(R1) + 1 \rightarrow R$
                \item \textbf{Decremento} (DEC). $(R1)-1 \rightarrow R$
                \item \textbf{Complemento} (CMP). $1 = 0; 0=1$
                \item \textbf{Reset} (RES).
                \item \textbf{Set} (SET).
            \end{itemize}

        \subsubsection{Instrucciones, $\mu$operaciones y $\mu$órdenes}

            Un programa se compone de una serie de instrucciones, compuestas a su vez en ciclos (fases),
            $\mu$operaciones y $\mu$órdenes.

            Una instrucción se compone de cuatro ciclos; de captación, de indirección, de ejecución y 
            de interrupción. Cada ciclo comprende la realización de una serie de pasos; y para ejecutar 
            cada uno de ellos se deben realizar una serie de operaciones atómicas o $\mu$operaciones.

            Cada conjunto de $\mu$órdenes que se emite en un ciclo de reloj de la unidad de control, se 
            denomina $\mu$instrucción.

            Una instrucción en lenguaje máquina se divide en $\mu$instrucciones.

        \subsubsection{Tipo de instrucciones}

            \begin{enumerate}
                \item Pueden ser de procesado de datos, donde se realicen operaciones aritméticas u operaciones 
                lógicas.
                \item Pueden llevar a cabo instrucciones de transferencia de información, bidireccionalmente 
                entre la memoria y el módulo de entrada y salida, o entre la memoria y los registros de la CPU.
                \item Pueden ser de control de flujo, como comprobación de un resultado o la alteración de la secuencia 
                normal.
            \end{enumerate}

            La representación de las instrucciones se realiza a através de una cadena de bits, cuyo conjunto se 
            divide en campos, y cada campo indica un tipo de información; de tal forma que el formato de la 
            instrucción determina el número de campos que debe tener esa instrucción, la longitud de cada campo, 
            su contenido y la posición del campo dentro de la cadena de bits (véase figura \ref{formatoinstruccion}).

            \begin{figure}[htp]
                \centering
                \includegraphics[width=0.8\textwidth]{resources/formatoinstruccion.png}
                \caption{Ejemplo de formato de instrucción.}
                \label{formatoinstruccion}
            \end{figure}

            Dependiendo del tipo de instrucción que se procese, puede manejar unos tipos de datos diferentes, siendo:

            \begin{itemize}
                \item Direcciones.
                \item Números.
                \item Caracteres.
                \item Datos lógicos (cadenas de $n$ bits manejados de forma individual).
                \item Estructura de datos.
            \end{itemize}

            Otro aspecto a considerar dentro de las instrucciones es el tipo de operación que deben desarrollar, 
            clasificadas en:

            \begin{itemize}
                \item De transferencia.
                \item Aritméricas.
                \item Lógicas.
                \item De conversión.
                \item De control de flujo.
                \item Instrucciones de control del sistema.
            \end{itemize}

    \subsection{La Unidad de Control}\label{unidadcontrol}

        La unidad de control es un circuito secuencial cuyo objetivo es captar, interpretar y ejecutar 
        las instrucciones almacenadas en memoria. Está formada por una serie de registros que gobiernan 
        su funcionamiento, siendo los más importantes los registros de control y de estado, que se utilizan 
        para mantener el control de los procesos. De entre ellos, los más importantes son:

        \begin{itemize}
            \item Registro contador de programa (CP), que contiene la dirección de la siguiente instrucción 
            a ejecutar.
            \item Registro de instrucción (RI), que contiene la instrucción captada más recientemente.
        \end{itemize}

        Dentro de cada instrucción debe existir un código de operación, que contenga el tipo de operación a 
        realizar (CO), la longitud de la instrucción (LI), el modo de direccionamiento (MD) y el número de 
        operandos.

        El campo de direcciones (CD) puede contener un dato inmediato, una dirección inmediata o una dirección 
        parcial. R1 y R2 es la identificación de los registros utilizaods en la instrucción.

        La dirección final DF es la dirección efectiva cuyo contenido es el dato que se quiere procesar, obtenido
        mediante el contenido de CD.

        \begin{itemize}
            \item \textbf{Registro de estado}. Contiene la información generada por el sistema.
            \item \textbf{Registro de estado de un programa}. Contiene información de estado del sistema y códigos 
            de condición sobre la última operación realizada en la ALU.
            \item \textbf{Registro de interrupciones}. Contiene información sobre los dispositivos que han producido 
            una interrupción.
            \item \textbf{Registro de punteros}. Contiene direcciones específicas de procesos en segmentación, paginación\dots
        \end{itemize}

        Por otro lado, en la unidad de control debe existir un decodificador, un controlador y un reloj del 
        sistema \footnote{
            El reloj de la CPU es el que genera los pulsos de reloj, que marcan la velocidad del microprocesador. Un ciclo 
            de CPU es un pulso electromagnético. En función del tipo de instrucción, se completará un número de pulsos 
            determinados.
        } (véase figura \ref{unidadcontrol} para mayor detalle).

        \begin{figure}[htp]
            \centering
            \includegraphics[width=0.8\textwidth]{resources/unidadcontrol.jpg}
            \caption{Esquema de la unidad de control.}
            \label{unidadcontrol}
        \end{figure}

        Como salida, la unidad de control genera las microórdenes a través de los buses dirigidos a todos los 
        componentes del sistema, trasferiendo información entre ellos, y por lo tanto la ejecución de $\mu$operaciones.

    \subsection{Unidad Aritmético-Lógica}

        Es un circuito combinacional que se encarga de realizar las operaciones con los datos, teniendo unas 
        entradas (correspondientes a las $\mu$órdenes existentes) que indican el tipo de operación a realizar 
        con los datos de entrada (véase figura \ref{alu}).

        \begin{figure}[htp]
            \centering
            \includegraphics[width=0.8\textwidth]{resources/alu.jpg}
            \caption{Esquema de la unidad aritmético-lógica.}
            \label{alu}
        \end{figure}

        Consta de una base de registros para realizar las operaciones necesarias; siendo éstos de propósito general 
        y visibles al programador de lenguaje máquina.

        \subsubsection{Modos de direccionamiento}

            Son los procesos que permiten conocer la localización de una instrucción o dato. Los modos de direccionamiento 
            dependen de la arquitectura del computador. De entre los más comunes encontramos:

            \paragraph{Direccionamiento inmediato} Se produce cuando el CD contiene un dato inmediato, y no la 
            dirección en la que se encuentra el dato. Si la longitud de la instrucción es P1 (una palabra) se produce 
            1 acceso a memoria; si por el contrario es P2 se producen 2 accesos a memoria (captura y ejecución).

            \paragraph{Direccionamiento directo} Se produce cuando el CD contiene la dirección del dato a recuperar.
            Si la longitud es P1, se producen 2 accesos a memoria (captura y ejecución); si por el contrario 
            la longitud es P2 se producen 3 accesos a memoria (1 en captura y 2 en ejecución); si la longitud es P3 
            (instrucciones con 2 operandos) se producen 5 accesos a memoria (1 en captura, 2 en ejecución y 2 en 
            recuperación del dato contenido en las direcciones CD1 y CD2).

            \paragraph{Direccionamiento indirecto} Se produce cuando el CD contiene una dirección cuyo contenido es otra 
            dirección de memoria con el dato.

            \paragraph{Direccionamiento mediante registros} En él, existe un trabajo (RT) que contiene el dato a procesar 
            o su dirección. El código MD (modo de direccionamiento) indica el registro utilizado y el tipo de contenido.

            \paragraph{Direccionamiento con desplazamiento} Siempre se referencian datos en la memoria principal; para obtener 
            el CD de memoria es preciso efectuar una suma.

            \paragraph{Direccionamiento por pilas} Se define su tamaño y permite incluir elementos en ella [la pila] 
            hasta el valor máximo.

    \subsection{Arquitectura CISC vs RISC}

        \subsubsection{Introducción a la ISA}

            Una ISA (Instruction Set Architecture) o arquitectura del conjunto de instrucciones es el repertorio de 
            instrucciones\footnote{
                Una instrucción no es más que un segmento de código que contiene implícita una operación que la CPU debe 
                realizar.
            } que puede entender y ejecutar la unidad de control de una determinada CPU. Eso no solo 
            incluye las instrucciones (tipos, codificación,…) comprensibles por la CPU, sino también el tipo de 
            datos aceptados de forma nativa, endianness, tamaño y cantidad de registros, arquitectura de la memoria, 
            e interrupciones/excepciones, extensiones, branching, etc. 

            En otras palabras, podríamos considerar a la ISA como la capa visible al programador a bajo nivel.

            Una ISA puede ser implementada (cómo se van a procesar o tratar sus instrucciones y datos) sobre lo que se 
            conoce como \textit{microarquitectura}\footnote{
                No hay que confundir el término microarquitectura ($\mu$arch) con arquitectura. Ésta segunda engloba 
                tanto la ISA como la microarquitectura, además de otros elementos y aspectos más amplios dentro del 
                sistema en conjunto del computador, que son estudiados en esta asignatura.
            }. Para ello será necesario contar con una serie de unidades funcionales
            (multiplexores, ALU, FPU, registros, unidad de control y demás circuitería).

            Diferentes microarquitecturas pueden ser compatibles con una misma ISA, pero una microarquitectura no 
            podrá procesar otra ISA diferente para la que fue diseñada; al menos de forma nativa.

            Dentro de las ISAs encontramos varios tipos, que diferenciándolas \textit{grosso modo} en el tamaño 
            del repertorio de instrucciones y longitud obtenemos:

        \subsubsection{CISC}
        
            Son las siglas de Complex Instruction Set Computer, es decir, un modelo de 
            ISA complejo. Se compone de instrucciones largas, gran número de ellas y que pueden realizar 
            bastantes operaciones complejas con los oprandos situados en la memoria o registros. Aparecieron 
            antes que otros tipos, por eso CISC es un retrónimo. Algunos ejemplos de CISC son IBM System/370, 
            Zilog Z80, Motorola 68k, National Semiconductor 32016, MOS Technology 6502, DEC PDP-11, DEC VAX, 
            x86 (pre-x86, x86-8, x86-16, x86-32, x86-64), IBM z/Architecture, etc.

            Algunas características propias de este tipo son:

            \begin{itemize}
                \item La complejidad hace que el coste y el tiempo invertido en la implementación sea mayor.
                \item Suele tener una unidad de control microprogramada, más lenta y menos eficiente.
                \item Dispone de pocos bancos de registros de propósito general.
                \item Suelen ocupar más espacio en el silicio, lo que encarece su producción y baja el yield.
                \item Tamaño variable y largo. Gran cantidad de instrucciones, llegando a las 500 en algunos casos. 
                Necesitan varios ciclos de duración, por tanto el CPI es mayor, o lo que es lo mismo, el IPC es menor.
                \item Tenemos más cantidad de modos de direccionamiento y complejos.
                \item El tiempo de programación es menor, una de las pocas ventajas de CISC frente a RISC.
                \item El compilador no es crítico y puede ser más sencillo.
                \item El programa suele ser más compacto, ya que con pocas instrucciones complejas basta.
                \item La abstracción es alta, siendo el software algo más independiente del hardware.
            \end{itemize}

        \subsubsection{RISC}\label{risc}
        
            Son las siglas de Reduced Instruction Set Computer, es decir, un modelo de 
            ISA simple que surge para resolver algunos problemas destacados de los CISC. A finales de los 70 
            se comenzó a ver un fenómeno curioso, y es que algunas versiones de arquitecturas CISC de gama 
            baja a las que se le retiraban algunas de las instrucciones complejas para reducir costes en la 
            implementación, en vez de ir peor mejoraban su rendimiento. Por ese motivo se comienzan a diseñar 
            los primeros RISC con repertorios de instrucciones más reducidos e instrucciones simples. 
            Ejemplos son el AMD 29000, ARM, DEC Alpha, RISC-V, MIPS, HP PA-RISC, IBM PowerPC/POWER, SPARC, 
            etc.

            Algunas características propias de este tipo son:

            \begin{itemize}
                \item El tiempo de desarrollo para una microarquitectura de este tipo es más bajo y el coste más reducido.
                \item El tipo de unidad de control suele ser cableada, es decir, mucho más rápida y eficiente.
                \item Suelen tener gran cantidad de registros de propósito general.
                \item El espacio de integración es más bajo en igualdad de condiciones. Es decir, el dado o core tendrá 
                menor superficie.
                \item El tamaño de instrucciones es fija y corta. En cuanto a cantidad, suele ser reducido, normalmente 
                inferior a las 128 instrucciones. Suelen durar solo un ciclo de duración.
                \item La cantidad de modos de direccionamiento de memoria son pocos y simples.
                \item El tiempo de programación es más elevado.
                \item El compilador debe ser complejo y muy eficiente.
                \item El tamaño del programa generado es hasta un 30\% mayor al necesitar de más instrucciones 
                simples para realizar una misma tarea en comparación con CISC.
                \item La abstracción software/hardware es baja. El software está muy ligado al hardware.
            \end{itemize}

            \paragraph{}{RISC-V} Dentro de las RISC existen muchas ISAs en actual uso, entre ellas las conocidas \textit{SuperH}, \textit{ARM} 
            (con buena relación rendimiento/eficiencia energética), \textit{RISC} y \textit{MIPS} (las primeras de ellas, por 
            ello llevan el nombre de RISC), etc.

            Pero la más moderna y que merece mención especial es \textit{RISC-V}. Ésta se desarrolla sobre una licencia 
            libre (\textit{BSD}). Iniciado por Berkeley con fondos del DARP, y actualmente participan en su creación multitud 
            de miembros de la fundación

        \subsubsection{Otros tipos}

            Aunque CISC y RISC son los dos grandes tipos de ISA y más relevantes, existen otros:
            
            \begin{itemize}
                \item \textbf{ZISC} Zero Instruction Set Computer no cuenta con un conjunto de instrucciones (en el sentido 
                clásico). Se basa en la mera coincidencia de patrones, similar a los computadores analógicos donde tampoco 
                existían, aunque aquí hablamos de computadoras digitales. Ha habido pocas implementaciones de este tipo, algún 
                ejemplo sería el IBM ZISC35 o el ZISC78, e incluso algunos chips neuronales como el CM1K…
                \item \textbf{SISC} Specific Instruction Set Computer es similar a RISC, de hecho se podría catalogar como tal, 
                pero es aún más reducidopara optimizar el rendimiento para alguna aplicación específica. Empleado en algunos 
                microcontroladores y ASIPs. Un ejemplo, algunos autores dicen que el DSP TMS320 de TI (Texas Instruments) es 
                SISC y otros lo etiquetan como RISC…
                \item \textbf{VISC} Virtual Instruction Set Computer es otro tipo introducido por Soft Machines.
                \item \textbf{DISC} Dynamic Instruction Set Computer puede modificar el conjunto de instrucciones de forma dinámica 
                según la demanda o exigencias del programa. Se suele usar para FPGAs reconfigurables.
                \item \textbf{NISC} No Instruction Set Computer tiene una tecnología muy específica de compilador y se emplea en 
                CPUs de alta eficiencia para algunas aplicaciones críticas, aceleradores por hardware, etc. No necesita de ROM de 
                microcódigo, ni controladores sofisticados, ni decodificador de instrucciones, etc.
                \item \textbf{MISC} Minimal Instruction Set Computer también es un conjunto muy reducido de instrucciones, pero a
                diferencia de otros como SISC o RISC, los operandos se almacenan en la pila en vez de en los registros, reduciendo 
                así el tamaño de los operandos y simplificando al máximo la microarquitectura. Funciona rápido y la unidad de 
                decodificación de instrucciones es más pequeña.
                \item \textbf{EDGE} Explicit Data Graph Execution intenta mejorar las carencias de CISC y evitar los problemas de 
                cuello de botella. Contiene muchas instrucciones individuales en un grupo denominado hyperblock y puede ser 
                ejecutado en paralelo.
                \item \textbf{OISC} One Instruction Set Computer, también llamado URISC (Ultimate RISC). Usa solo una instruccion 
                sin limitar las aplicaciones. Sus implementaciones se usan especialmente para la enseñanza. Imagina una instrucción 
                SUBLEQ que reste el contenido de dos direcciones de memoria y almacene el resultado en otra dirección. Con esa única 
                instrucción, ejecutandola secuencialmente se podrían conseguir los equivalentes a varias instrucciones. Por ejemplo, 
                si se ejecuta SUBLEQ b, b + SUBLEQ a, Z + SUBLEQ Z, b + SUBLEQ Z, Z = MOV a, b.            
            \end{itemize}

        \subsubsection{Híbridos CISC-RISC (RISC-Like)}

            Algunos diseñadores de microarquitecturas CISC han querido obtener las ventajas de RISC sin abandonar el modelo CISC o sin 
            perjudicar a la compatibilidad del software escrito para su ISA. Eso sería el caso de x86. CISC es un modelo antiguo y con 
            carencias, pero ¿cómo pasarse a RISC sin crear una nueva ISA y sin que todo el software compatible tenga que ser compilado 
            para esta nueva arqutiectura? La solución es la hibridación.

            Uno de los primeros diseños RISC-like sería el AMD K5, que usaba la exitosa microarquitectura del 29k a la que le añadieron 
            un Front-End para traducir las CISC-x86 y posibilitando que el Back-End trabajase de forma superescalar, con ejecución fuera 
            de orden, ejecución especulativa, renombre de registros, etc., sin alterar la compatibilidad con x86.

            Actualmente, los diseños de Intel y AMD trabajan como RISC a nivel electrónico, aunque el repertorio de instrucciones sea 
            CISC.

\section{Memoria}\label{memoria}

    %\subsection{Aspectos físicos}

        Las memorias tienen una serie de características físicas a tener en cuenta:

        \begin{itemize}
            \item \textbf{Volatilidad}. Capacidad de retener o perden la información almacenada en caso de 
            corte de suministro eléctrico.
            \item \textbf{Alertabilidad}. Posibilidad de alterar el contenido de una memoria.
            \item \textbf{Permanencia de la información}. Relaciona la duración de la información almacenada.
            \item \textbf{Almacenamiento estático/dinámico}. Una memoria es estática cuando su información 
            permanece inalterable a lo largo del tiempo (véase SRAM); una memoria es dinámica cuando necesita 
            realizar un ciclo de refresco para poder retener la información que almacena (DRAM).  
        \end{itemize}

        En función del tiempo de almacenamiento mencionado, se hará distinción en la volatilidad. Por el lado volátil 
        observamos la memoria RAM dinámica (DRAM - que contiene los programas en ejecución y los datos con los que operan), 
        la memoria caché (típicamente SRAM, más rápida que DRAM pero con mayor consumo energético y menor capacidad) y los 
        registros del procesador. Estas memorias, junto a la ROM (no volátil) comprenden el denominado almacenamiento 
        primario del ordenador.

        Frente a él, el denominado almacenamiento secundario o almacenamiento masivo, que requiere el uso de buses 
        de entrada/salida para acceder a la información, usualmente no volátil. Este tipo de almacenamiento tiene un 
        tiempo de acceso mucho mayor que el primario, su capacidad de almacenamiento supera ampliamente la del almacenamiento 
        principal.

        En resumen, las características de la memoria principal son: electrónicas, con alta velocidad, tamaño limitado, 
        volátil o no volátil, imprescindible y de elevado coste. Mientras que las de la memoria secundaria son: 
        magnética u óptica, velocidad reducida en comparación, tamaño ilimitado, permanente y estática, opcional en el sistema 
        y de bajo coste.

        \begin{figure}[htp]
            \centering
            \includegraphics[width=0.8\textwidth]{resources/jerarquiamemoria.png}
            \caption{Jerarquía de memorias.}
            \label{jerarquiamemoria}
        \end{figure}

\section{Módulo de Entrada y Salida}\label{entradasalida}

    La entrada y salida de datos representa el medio de comunicación existente entre el usuario y el 
    ordenadr, logrando a su vez la eficiencia en las operaciones de E/S y minimizando el trabajo a 
    realizar a la CPU.

    Cuenta con dos elementos básicos unidos por los correspondientes buses:

    \subsection{Interfaz o controlador del periférico}

        Sistema mixto hardware/software que posibilita la comunicación entre la CPU/memoria y el 
        periférico, siendo sus principales funciones:

        \begin{itemize}
            \item Control de transferencia de datos entre dispositivo y procesador,
            \item Adaptación de longitud y formato de datos.
            \item Arbitraje de bus.
            \item Adaptación de los tiempos de transferencia de CPU y periférico.
            \item Adaptación de señales eléctricas para la conexión de un periférico.
            \item Decodificación de las órdenes provenientes del procesador.
            \item Averiguar qué dispositivo se encuentra disponible para transferir datos.
            \item Comunicación con los dispositivos.
            \item Almacenamiento temporal de datos.
            \item Detección de errores en el funcionamiento del dispositivo.
        \end{itemize}

    \subsection{Operación de entrada/salida (E/S)}

        La operación de entrada/salida se lleva a cabo de la siguiente manera:

        \begin{quote}
            \small En primer lugar, se comprueba si el dispositivo está listo, leyendo el registro 
            de estado del controlador, donde un bit indicará si puede comenzar a transferir una palabra.

            El registro de control indicará el tipo de operación a realizar, donde los distintos bits de 
            dicho registro indican cada una de las distintas acciones a llevar a cabo por el 
            periférico.

            Para comenzar una operación, el procesador debe escribir sobre los registros anteriores los 
            distintos datos de la operación a través de una dirección de E/S o memoria asignada únicamente 
            al controlador. Después, se transfiere el dato usando el registro de datos.

            Una vez concluida la transferencia debe indicarse en el registro de control.
        \end{quote}

    \subsection{Dispositivos periféricos}

        Son aquellos dispositivos que se conectan con el procesador. Éstos permiten realizar operaciones 
        de E/S en las que suelen intervenir memoria y CPU. Para conectar estos 3 componentes se utilizan 
        los siguientes buses:

        \begin{itemize}
            \item Bus de direcciones.
            \item Bus de datos.
            \item Bus de control.
        \end{itemize}

    \subsection{Tipos de entrada/salida}

        Hay 3 tipos fundamentales por los cuales puede realizarse la operación de E/S:

        \subsubsection{E/S por intrrupciones}

            La E/S se realiza mediante una rutina de atención a la interrupción, donde el dispositivo 
            indica a la CPU cuando está listo.

        \subsubsection{E/S por consulta o programada}

            Se realiza una consulta periódica al dispositivo para saber cuándo se encuentra disponible 
            para operar. Es un proceso de mayor sencillez, pero la velocidad de transferencia está limitada 
            a la velocidad que imponga la CPU. Además, existe el riesgo de sobrecarga.

        \subsubsection{E/S por acceso directo a memoria}

            El dispositivo accede directamente a memoria y se encarga de avisar a la CPU tanto del inicio 
            como del final de la tarea. La velocidad de transferencia obtenida es superior.

\section{Buses}

    Los buses interconectan los elementos componentes de un ordenador mediante conjuntos de conductores 
    eléctrico, soporte material de las señales eléctricas.

    La función de este sistema es la de transferir señales de control (sincronización, códigos de operación 
    en sentido general, etc) y datos (operandos, resultados).

    De las conexiones y transferencias que se pueden establecer son:

    \begin{enumerate}
        \item De memoria al procesador y viceversa.
        \item Del módulo de E/S al procesador y viceversa.
        \item De memoria al módulo de E/S y viceversa.
    \end{enumerate}

    Cada una de estas transferencias requiere de múltiples señales, de tal forma que se puede definir un bus 
    como un mecanismo de interconexión componentes de un dispositivo digital. No responde éste únicamente al 
    establecimiento de un camino físico, sino que conlleva una política de uso y acceso por parte de los 
    elementos interconectados.

    Está compuesto de varias líneas, donde cada línea es capaz de transferir las señales binarias. Si se transmiten 
    varios bits simultáneamente por diferentes líneas del bus, se dice que es una transmisión paralela.

    Los buses cuentan con distintas señales para facilitar su funcionamiento:

    \begin{itemize}
        \item Líneas de dirección.
        \item Líneas de datos.
        \item Líneas de control.
    \end{itemize}

    \subsection{Organización maestro/esclavo}

        En este sistema organizativo, el maestro o \textit{bus master} es el encargado de iniciar la transacción, 
        enviando para ello las direcciones de los dispositivos intervinientes y activando las señales de control 
        correspondientes.

        El esclavo o \textit{bus slave} se encarga de responder a la operación indicada por el maestro.

    \subsection{Jerarquía de buses}

        La jerarquía de buses define las presaciones del bus, determinadas en gran parte por el ancho de 
        éste y por la velocidad del reloj que controla las transferencias.

        Según la jerarquía podemos distinguir hasta 5 tipos de buses:

        \subsubsection{Buses tipo 0}

            Los mas rápidos. Se corresponde con los buses internos de los dispositivos.
        
        \subsubsection{Buses tipo 1}

            Se corresponde con el bus existente dentro de las placas que conecta los distintos componentes 
            soldados o pinchados a ella.

        \subsubsection{Buses tipo 2}

            Es el encargado de conectar las placas de un módulo con la placa base.

        \subsubsection{Buses tipo 3}

            Es denominado bus del sistema, conectando los módulos y componentes.

        \subsubsection{Buses tipo 4}

            Conectan los periféricos.

        \subsubsection{Buses tipo 5}

            Son los más comunes a la hora de comunicar periféricos, debido a que pueden transmitir en 
            semi-duplex o full-duplex.

    \subsection{Tipos de buses}

        En función de la política de utilización del bus podemos tener distintos tipos:

        \subsubsection{Bus dedicado}

        \subsubsection{Bus multiplexado en el tiempo}

        \subsubsection{Bus backplane}

        \subsubsection{Bus E/S y procesador-memoria}

        \subsubsection{Bus procesador-memoria y E/S}

    \subsection{Estandarización de los buses}

			
\end{document}